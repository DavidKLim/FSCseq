% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FSCseq.R
\name{FSCseq}
\alias{FSCseq}
\title{Wrapper for main FSCseq function}
\usage{
FSCseq(ncores = 1, X = NULL, y, k, lambda = 0, alpha = 0,
  size_factors = rep(1, times = ncol(y)), norm_y = y,
  true_clusters = NULL, true_disc = NULL, init_parms = FALSE,
  init_coefs = matrix(0, nrow = nrow(y), ncol = k),
  init_phi = matrix(0, nrow = nrow(y), ncol = k), init_cls = NULL,
  init_wts = NULL, init_method = "max", n_rinits = if (method ==
  "EM") {     20 } else {     10 }, maxit_inits = if (method == "EM") {  
    15 } else {     ceiling(log(2/nrow(y))/log(0.9)) }, maxit_EM = 100,
  maxit_IRLS = 50, EM_tol = 1e-06, IRLS_tol = 1e-04,
  disp = c("gene", "cluster"), optim_method = "direct",
  method = c("EM", "CEM"), init_temp = sqrt(nrow(y)), trace = F,
  trace.file = NULL, mb_size = NULL)
}
\arguments{
\item{X}{(optional) design matrix of dimension n by p}

\item{y}{count matrix of dimension g by n}

\item{k}{integer, number of clusters}

\item{lambda}{numeric penalty parameter, lambda >= 0}

\item{alpha}{numeric penalty parameters, 0 <= alpha < 1}

\item{size_factors}{numeric vector of length n, factors to correct for subject-specific variation of sequencing depth}

\item{norm_y}{count matrix of dimension g by n, normalized for differences in sequencing depth}

\item{true_clusters}{(optional) integer vector of true groups, if available, for diagnostic tracking}

\item{true_disc}{(optional) logical vector of true discriminatory genes, if available, for diagnostic tracking}

\item{init_parms}{logical, TRUE: custom parameter initializations, FALSE (default): start from scratch}

\item{init_coefs}{matrix of dimension g by k, only if init_parms = TRUE}

\item{init_phi}{vector of dimension g (gene-specific dispersions) or matrix of dimension g by k (cluster-specific dispersions), only if init_parms = TRUE}

\item{init_cls}{(optional) vector of length n, initial clustering. If NA (default), multiple initializations will be searched}

\item{init_wts}{(optional) matrix of dim k by n to denote initial clustering (allowing partial membership). If both init_cls and init_wts specified, init_wts will be ignored and init_cls used as initial clusters}

\item{init_method}{if searching over (n_rinits+2) initializations (random + HC and KM inits) --> how to choose optimal init to run full EM.}

\item{n_rinits}{integer, number of additional random initializations to be searched (default 50 for EM, 10 for CEM)}

\item{maxit_inits}{integer, maximum number of iterations for each initialization search (default 15 for EM, or until temperature anneals down to below 2 for CEM)}

\item{maxit_EM}{integer, maximum number of iterations for full EM/CEM run (default 100)}

\item{maxit_IRLS}{integer, maximum number of iterations for IRLS algorithm, in M step (default 50)}

\item{EM_tol}{numeric, tolerance of convergence for EM/CEM, default is 1E-8}

\item{IRLS_tol}{numeric, tolerance of convergence for IRLS, default is 1E-6}

\item{disp}{string, either "gene" (default) or "cluster"}

\item{optim_method}{string, three options "direct", "NR", or "GD". Direct, Newton-Raphson, or Gradient descent (fixed step size of 2)}

\item{method}{string, either "EM" (default) or "CEM"}

\item{init_temp}{numeric, default for CEM: init_temp = nrow(y), i.e. number of genes. temp=1 for EM}

\item{trace}{logical, TRUE: output diagnostic messages, FALSE (default): don't output}

\item{mb_size}{minibatch size: # of genes to include per M step iteration}
}
\value{
list containing outputs from EM_run() function
}
\description{
Determine and search HC, KM, and random initializations by BIC,
and then full EM/CEM run based on the optimal one.
Calls EM_run function to perform the clustering.
}
